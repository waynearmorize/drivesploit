require 'rex/text'
require 'rex/exploitation/drivesploitrandomizer'
require 'rex/exploitation/drivesploitencryptor'
require 'rex/exploitation/drivesploitnumericliteral'

module Rex
module Exploitation
  
class JSObfuscate

  def initialize(value)
    @originalString = value
    @concatenations = []
    @deobfuscationLayers = []
    @functionName = self.randomString(20)
    self.obfuscate
  end

#this functions is not really needed, just to show it on the browser
  def originalString
    return @originalString
  end
  def jstextarea
    jscode = "<script type=\"text/javascript\">function #{@functionName}() {"
    for i in 0..@deobfuscationLayers.count-1
      jscode+= self.shuffle(@deobfuscationLayers[i]).gsub(/``````/, ";")
    end
    jscode+= "document.write('<textarea style=\"width: 1000px; height: 200px;\">'+#{@concatenations[@concatenations.count-1]}+'</textarea>')"
    jscode+= "}"
    jscode+= "</script>"
    return jscode
  end
#end of not needed functions

  def getFunctionName #this function will return the random JS function name
    return @functionName
  end

  def getObfuscation #this function will return the obfuscated JS code
    jscode = "<script type=\"text/javascript\">"
    for i in 0..@deobfuscationLayers.count-1
      jscode+= self.shuffle(@deobfuscationLayers[i]).gsub(/``````/, ";")
    end
    jscode+= "document.write(#{@concatenations[@concatenations.count-1]});"
    jscode+= "</script>"
    return jscode
  end

  def assignment
    jscode = ''
    for i in 0..@deobfuscationLayers.count-1
      jscode+= self.shuffle(@deobfuscationLayers[i]).gsub(/``````/, ";") + "\n"
    end
    return [jscode, @concatenations[@concatenations.count-1]]
  end

  def eval
    jscode = ''
    for i in 0..@deobfuscationLayers.count-1
      jscode+= self.shuffle(@deobfuscationLayers[i]).gsub(/``````/, ";")
    end
    return "#{jscode};\neval(#{@concatenations[@concatenations.count-1]});"
  end

  def randomString(chars) #this function will return a string with random characters
    lettersOnly = ('a'..'z').inject(:+) + ('A'..'Z').inject(:+)
    alphanumeric = lettersOnly + ('0'..'9').inject(:+)
    newString = ""
    for i in 1..chars
      if i == 1
        newString+= lettersOnly[rand(lettersOnly.length)].chr #JS variables can't start with a number, so must be a letter
      else
        newString+= alphanumeric[rand(alphanumeric.length)].chr
      end
    end
    return newString
  end
  def getInsertion(input, len, min, max)
    newString = ""
    randinsertion = self.randomString(len)

    while input.length >= max
      numberOfChars = rand(max-min+1) + min
      for i in 0..numberOfChars-1
          extractedCharacter = input[i].chr
          newString+= extractedCharacter
      end
      newString+= randinsertion
      if input.length > numberOfChars
        input = input[numberOfChars..input.length-1]
      else
        input = ""
      end   
  end
    newString = newString + input
    return [newString, randinsertion]
  end

  def getNewString(newString)
    varName = self.randomString(8)
    return ["#{varName} = \"#{newString}\";", randinsertion, varName]
  end

  def getRegEx(oldVar, randinsertion)
    varName = self.randomString(8)
    return ["#{varName} = #{oldVar}.replace(/#{randinsertion}/g, \"\");", varName]
  end


  def shuffle(text) #this function will shuffle a string full of 'xxx=yyy;' variables so they don't appear in order
    varArray = text.split(';')
    shuffledArray = varArray.sort_by{rand}
    newText = ""
    shuffledArray.each do |i|
     newText+= i + ";"
    end
    return newText
  end

  def obfuscate #this function will perform the obfuscation
    string = @originalString.gsub(/\r\n/, " ") #remove new lines, it generates conflicts
    string = string.gsub(/\n/, " ") #remove new lines, it generates conflicts
    #the first layer of Obfuscation [ layer 0 ] will chop the string into pieces of 3~6 characters and set random name variables
    jsVariables = "" #initialize a string to chop the text into variables. i.e: "abcdefghij" -> AAA="abc";BBB="defg";CCC="hij";
    jsGroups = "" #initialize a string to 'glue' variables together. i.e: AAA+BBB+CCC
    layer = 0;
    while string.length > 6 do #while there are more than 6 characters left in the string
      jsVariables+= ''
      bytes = ('6'..'9').inject(:+) #how many characters ( from 3 to 6 [ 0~5 ] ) to put in the block
      numberOfChars = bytes[rand(bytes.length)].chr.to_i
      numberOfVarChars = bytes[rand(bytes.length)].chr
      newVarName = self.randomString(6)
      jsVariables+= newVarName + '="' #this generates the -> AAA=" <- part in [ AAA="xxx"; ]
      jsGroups+= newVarName + "+"
      if numberOfChars >= string.length
        numberOfChars = string.length - 1
      end
      for i in 0..numberOfChars
        extractedCharacter = string[i].chr
        if extractedCharacter == ';' #if the character is -> ; <- we need to convert it into -> `````` <- or will break our variables
          extractedCharacter = '``````'
        end
        if extractedCharacter == '"' #if the character is -> " <- we need to convert it into -> \" <- or will break our variables
          extractedCharacter = '\"'
        end
        if extractedCharacter == '\\' #if the character is -> \ <- we need to convert it into -> \\ <- or will break our variables
          extractedCharacter = '\\\\'
        end
        jsVariables+= extractedCharacter
      end
      jsVariables+= '";' #this generates the -> "; <- part in [ AAA="xxx"; ]
      string = string[numberOfChars.to_i+1..string.length] #cut the string to take out the characters already tokenized
    end
    #in case there are 1 to 6 characters left in the string, we need to generate a new JS variable to save those last characters
    jsVar = self.randomString(6)
    string = string.gsub(/\\/, "\\\\\\").gsub(/;/, "``````").gsub(/"/, "\\\"")
    jsGroups+= jsVar
    jsVariables+= jsVar +"=\"#{string}\";"
    #once finished the first layer of obfuscation [ layer 0 ], we save the Groups and Variables into the arrays that will generate the JS Code later
    @concatenations[layer] = jsGroups
    @deobfuscationLayers[layer] = jsVariables
    #from here, the following layers of Obfuscation [ layer 1-2-3-4...n ] will group 2 variables into 1. i.e. AAAA=BBB+CCC; DDDD=EEE+FFF; until there is only 1 variable grouping them ALL
    vars = jsVariables.split(';') #we split the string holding the variables to work as an array
    totalvars = vars.count #count how many variables in the array to join
    numberOfChars = 6 #max number of characters on the previous layer [ 0 ]
    while totalvars.to_i > 1 #while there are more than 1 variable, lets join them!
      layer+= 1 #increase obfuscation layer at every loop
      numberOfChars+= 1 #increase number of characters for each layer. i.e: layer 0: ABCDEF, layer 1: ABCDEFG, layer 2: ABCDEFGH...
      jsGroups = ""
      jsVariables = ""
      group = ""
      items = 0
      for i in vars
        items+= 1
        varName = i.split('=') #we extract the the variable name. i.e: BBB="ccc" -> BBB
        if items < 2 #if there are less than 2 items [ JS Vars ] in the group, we start joining method. i.e: BBB+
          group+= varName[0]+"+"
        else #if there are already 2 items in the group, we added to the jsVariables and jsGroups strings.
          group+= varName[0] #add the 2nd item. i.e: BBB+CCC
          newVarName = self.randomString(numberOfChars)
          jsVariables+= newVarName + "=" + group + ";" #i.e: AAAA=BBB+CCC;
          jsGroups+= newVarName + "+" #i.e: AAAA+
          group = "" #clean the group
          items = 0 #reset the items counter
        end
      end
      #if at the end of the loop, there is an orphaned var ( not coupled ), we added to the string too or we will lose it
      if group != ""
        newVarName = self.randomString(numberOfChars)
        jsVariables = jsVariables + newVarName + "=" + group.chop + ";" #i.e: DDDD=FFF;
        @concatenations[layer] = jsGroups + newVarName
      else
        @concatenations[layer] = jsGroups.chop #if there was no orphaned group, we take the last [+] character. i.e: AAAA+BBBB+CCCC+ -> AAAA+BBBB+CCCC
      end
      @deobfuscationLayers[layer] = jsVariables
      vars = jsVariables.split(';') #we make a new 'vars' array to start grouping the processed layer
      totalvars = vars.count #we count how many variables left to see if we arrived to the end = 1!
    end
  end

end # END OF CLASS -> JSObfuscate

class DriveSploit
  STRING_CONCAT=1
  AUTO_RANDOM_VARS=2
  FINGERPRINT_DECRYPT=3

  def self.obfuscate(body, type = STRING_CONCAT, browser = "ie6")
    DriveSploit.new().obfuscate(body, type, browser)
  end
  def self.obfuscatejs(body, type = STRING_CONCAT, browser = "ie6")

    DriveSploit.new().obfuscatejs(body, type, browser)
  end
  
  def initialize()
  end
  
  def obfuscatejs(body, type = STRING_CONCAT, browser = "ie6") 

      case type
      when STRING_CONCAT
          d = JSObfuscate.new(body)
          obj = d.assignment()
          return obj
      when AUTO_RANDOM_VARS
          d = Rex::Exploitation::DriveSploitRandomizer.new()
          obj = d.obfuscate(body)
          return obj
      when FINGERPRINT_DECRYPT
          d = Rex::Exploitation::DriveSploitEncryptor.new()
          obj = d.encryptjs(body, browser)
	  keycode = d.getkeycode()
          jcode = d.getjscode()
          obj << keycode
          obj << jcode

          return obj
      else
          return body
      end
  end
  def obfuscate(body, type = STRING_CONCAT, browser = "ie6")
      case type
      when STRING_CONCAT
          d = JSObfuscate.new(body)
          obf = d.getObfuscation()
          return "<html><body>#{obf}</body></html>"
      when AUTO_RANDOM_VARS
          d = Rex::Exploitation::DriveSploitRandomizer.new()
          obj = d.obfuscate(body)
          # here we'll need to build html
          return obj
      when FINGERPRINT_DECRYPT
          d = Rex::Exploitation::DriveSploitEncryptor.new()
          obj = d.obfuscate(body, browser)
          # here we'll need to build html
          return obj
      else
          return body
      end
  end
  def obfuscateNumber(target)
    d = Rex::Exploitation::DriveSploitNumber.new()
    obj = d.obfuscateNumber(target)
    return obj
  end

# proxy some methods
  def self.randomString(chars)
      DriveSploit.new().randomString(chars)
  end
  def randomString(chars)
      JSObfuscate.new("").randomString(chars)
  end
  def self.getInsertion(input, len, min, max)
      DriveSploit.new().getInsertion(input, len, min, max)
  end
  def getInsertion(input, len, min, max)
      JSObfuscate.new("").getInsertion(input, len, min, max)
  end

  def self.getNewString(s)
      DriveSploit.new().getNewString(s)
  end
  def getNewString(s)
      JSObfuscate.new("").getNewString(s)
  end

  def self.getRegEx(s, s1)
      DriveSploit.new().getRegEx(s,s1)
  end
  def getRegEx(s,s1)
      JSObfuscate.new("").getRegEx(s,s1)
  end

  def self.obfuscateNumber(target)
      DriveSploit.new().obfuscateNumber(target)
  end


end  # DriveSploit

end # Exploitation
end # Rex
